##! BIFs for shunting with conn_ids using XDP. This interface is private, use
##! script functions instead.

%%{
#include "zeek/IPAddr.h"
#include "zeek/Val.h"

#include "ShuntUtil.h"
#include "XDPProgram.h"
#include "bpf/UserXDP.h"
#include "bpf/filter_common.h"
%%}

module XDP::Shunt::ConnID;

## Event raised whenever a connection is shunted.
event shunted_conn%(cid: conn_id%);
## Event raised whenever a connection is unshunted.
event unshunted_conn%(cid: conn_id, stats: XDP::ShuntedStats%); 

function _get_map%(xdp_prog: opaque of XDP::Program,
                time_since_last_packet: interval &default=0sec%) : XDP::shunt_table %{
    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    static auto shunt_table = zeek::id::find_type<zeek::TableType>("XDP::shunt_table");
    static auto canonical_id= zeek::id::find_type<zeek::RecordType>("XDP::canonical_id");
    auto zeek_table = zeek::make_intrusive<zeek::TableVal>(shunt_table);

    if ( ! zeek_prog ) {
        zeek::reporter->Error("%s", zeek_prog.error().c_str());
        return zeek_table;
    }

    auto prog = (*zeek_prog)->prog;

    auto shunt_map = get_map<canonical_tuple>(get_canonical_id_map(prog));
    for ( const auto&[key, val] : shunt_map ) {
        // Skip if we are still within time_since_last_packet
        if ( time_since_last_packet &&
            (time_since_last_packet + mono_to_wall(val.timestamp) > zeek::util::current_time(true)) )
            continue;

        auto zeek_key = zeek::make_intrusive<zeek::RecordVal>(canonical_id);
        if ( IN6_IS_ADDR_V4MAPPED(&key.ip1) )
            zeek_key->Assign(0, zeek::make_intrusive<zeek::AddrVal>(
                                    *reinterpret_cast<const uint32_t*>(&key.ip1.s6_addr[12])));
        else
            zeek_key->Assign(0,
                             zeek::make_intrusive<zeek::AddrVal>(reinterpret_cast<const uint32_t*>(&key.ip1.s6_addr)));

        zeek_key->Assign(1, zeek::val_mgr->Port(key.port1));

        if ( IN6_IS_ADDR_V4MAPPED(&key.ip2) )
            zeek_key->Assign(2, zeek::make_intrusive<zeek::AddrVal>(
                                    *reinterpret_cast<const uint32_t*>(&key.ip2.s6_addr[12])));
        else
            zeek_key->Assign(2,
                             zeek::make_intrusive<zeek::AddrVal>(reinterpret_cast<const uint32_t*>(&key.ip2.s6_addr)));

        zeek_key->Assign(3, zeek::val_mgr->Port(key.port2));
        zeek_key->Assign(4, zeek::val_mgr->Count(key.protocol));

        zeek_table->Assign(zeek_key, makeShuntedStats(true, &val));
    }

    return zeek_table;
%}

function _shunt%(xdp_prog: opaque of XDP::Program, cid: XDP::canonical_id%) : bool %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return zeek::val_mgr->Bool(false);

    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    if ( ! zeek_prog ) {
        zeek::reporter->Error("%s", zeek_prog.error().c_str());
        return zeek::val_mgr->Bool(false);
    }

    auto prog = (*zeek_prog)->prog;
    auto err = update_map(get_canonical_id_map(prog), &*opt_tup);

    if ( err ) {
        zeek::reporter->Error("Failed to add to map: %s", (*err).c_str());
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

function _shunt_stats%(xdp_prog: opaque of XDP::Program, cid: XDP::canonical_id%) : XDP::ShuntedStats %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return makeEmptyShuntedStats();

    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    if ( ! zeek_prog ) {
        zeek::reporter->Error("%s", zeek_prog.error().c_str());
        return makeEmptyShuntedStats();
    }

    auto prog = (*zeek_prog)->prog;
    auto opt_val = get_val(get_canonical_id_map(prog), &*opt_tup);
    if ( ! opt_val )
        return makeEmptyShuntedStats();

    return makeShuntedStats(origIsIp1(cid->AsRecordVal()), &*opt_val);
%}

function _unshunt%(xdp_prog: opaque of XDP::Program, cid: XDP::canonical_id%) : XDP::ShuntedStats %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return makeEmptyShuntedStats();

    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    if ( ! zeek_prog ) {
        zeek::reporter->Error("%s", zeek_prog.error().c_str());
        return makeEmptyShuntedStats();
    }

    auto prog = (*zeek_prog)->prog;

    auto opt_val = get_val(get_canonical_id_map(prog), &*opt_tup);
    if ( ! opt_val )
        return makeEmptyShuntedStats();

    auto err = remove_from_map(get_canonical_id_map(prog), &*opt_tup);

    if ( err ) {
        zeek::reporter->Error("Failed to remove from map: %s", (*err).c_str());
        return makeEmptyShuntedStats();
    }

    return makeShuntedStats(origIsIp1(cid->AsRecordVal()), &*opt_val);
%}
