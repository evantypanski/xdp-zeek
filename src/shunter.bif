%%{
#include "zeek/iosource/Manager.h"
#include "zeek/iosource/PktSrc.h"

#include "XDPProgram.h"
#include "bpf/UserXDP.h"
#include "bpf/filter_common.h"

std::optional<canonical_tuple> makeBPFMapTuple(zeek::RecordVal* cid_r) {
    const zeek::IPAddr& orig_h = cid_r->GetFieldAs<zeek::AddrVal>(0);
    uint16_t orig_p = cid_r->GetFieldAs<zeek::PortVal>(1)->Port();
    const zeek::IPAddr& resp_h = cid_r->GetFieldAs<zeek::AddrVal>(2);
    uint16_t resp_p = cid_r->GetFieldAs<zeek::PortVal>(3)->Port();
    uint8_t proto = cid_r->GetFieldAs<zeek::CountVal>(4);

    const uint32_t* orig_bytes;
    int len = orig_h.GetBytes(&orig_bytes);
    struct in6_addr ip1 = {0};
    if ( len == 1 ) {
        ip1.s6_addr[10] = 0xff;
        ip1.s6_addr[11] = 0xff;
        memcpy(&ip1.s6_addr[12], &orig_bytes[0], sizeof(uint32_t));
    }
    else
        memcpy(&ip1, orig_bytes, sizeof(struct in6_addr));

    const uint32_t* resp_bytes;
    struct in6_addr ip2 = {0};
    len = resp_h.GetBytes(&resp_bytes);
    if ( len == 1 ) {
        ip2.s6_addr[10] = 0xff;
        ip2.s6_addr[11] = 0xff;
        memcpy(&ip2.s6_addr[12], &resp_bytes[0], sizeof(uint32_t));
    }
    else
        memcpy(&ip2, resp_bytes, sizeof(struct in6_addr));

    auto tup = canonical_tuple{
        .ip1 = ip1,
        .ip2 = ip2,
        .port1 = orig_p,
        .port2 = resp_p,
        .protocol = proto,
    };

    // We order first by ip, or if they're equal, by port.
    if ( compare_ips(&tup.ip1, &tup.ip2) > 0 || ((compare_ips(&tup.ip1, &tup.ip2) == 0) && tup.port1 > tup.port2) ) {
        // Flip them, they're out of order
        std::swap(tup.ip1, tup.ip2);
        std::swap(tup.port1, tup.port2);
    }

    return tup;
}

std::optional<std::string> shuntSubnet(struct bpf_map* map, zeek::SubNetVal* subnet) {
    auto ip = subnet->Prefix();
    const uint32_t* bytes;
    int len = ip.GetBytes(&bytes);
    struct in6_addr ip_addr = {0};
    if ( len == 1 ) {
        ip_addr.s6_addr[10] = 0xff;
        ip_addr.s6_addr[11] = 0xff;
        memcpy(&ip_addr.s6_addr[12], &bytes[0], sizeof(uint32_t));
    }
    else
        memcpy(&ip_addr, bytes, sizeof(struct in6_addr));

    auto key = ip_lpm_key {
        .prefixlen = static_cast<__u32>(subnet->Width()),
        .ip = ip_addr,
    };

    return update_map(map, &key, XDP_DROP);
}

std::optional<std::string> unshuntSubnet(struct bpf_map* map, zeek::SubNetVal* subnet) {
    auto ip = subnet->Prefix();
    const uint32_t* bytes;
    int len = ip.GetBytes(&bytes);
    struct in6_addr ip_addr = {0};
    if ( len == 1 ) {
        ip_addr.s6_addr[10] = 0xff;
        ip_addr.s6_addr[11] = 0xff;
        memcpy(&ip_addr.s6_addr[12], &bytes[0], sizeof(uint32_t));
    }
    else
        memcpy(&ip_addr, bytes, sizeof(struct in6_addr));

    auto key = ip_lpm_key {
        .prefixlen = static_cast<__u32>(subnet->Width()),
        .ip = ip_addr,
    };

    return remove_from_map(map, &key);
}

%%}
module XDP;

function start_shunt%(options: XDP::ShuntOptions%) : opaque of XDP::Program %{
    auto options_val = IntrusivePtr<RecordVal>{NewRef{}, options->AsRecordVal()};
    auto opts = xdp_options {
        .mode = static_cast<xdp_attach_mode>(options_val->GetFieldAs<zeek::EnumVal>("attach_mode")),
    };
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    auto ifindex = if_nametoindex(ps->Path().c_str());
    if ( ifindex == 0 ) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    struct filter* skel = nullptr;
    auto err = load_and_attach(ifindex, opts, &skel);
    if ( err ) {
        zeek::reporter->Error("Failed to load BPF skeleton: %s", (*err).c_str());
        return zeek::val_mgr->Bool(false);
    }

    auto xdp_prog = zeek::make_intrusive<xdp::shunter::detail::XDPProgramVal>(skel);
    return xdp_prog;
%}

function get_canonical_id_map_keys%(xdp_prog: opaque of XDP::Program%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto keys = get_map<canonical_tuple>(get_canonical_id_map(prog));
    auto zeek_keys = zeek::make_intrusive<zeek::VectorVal>(zeek::make_intrusive<zeek::VectorType>(zeek::id::conn_id));
    for (auto key : keys) {
	      auto zeek_key = zeek::make_intrusive<zeek::RecordVal>(zeek::id::conn_id);
        if ( IN6_IS_ADDR_V4MAPPED(&key.ip1) )
            zeek_key->Assign(0, zeek::make_intrusive<zeek::AddrVal>(*reinterpret_cast<const uint32_t*>(&key.ip1.s6_addr[12])));
        else
            zeek_key->Assign(0, zeek::make_intrusive<zeek::AddrVal>(reinterpret_cast<const uint32_t*>(&key.ip1.s6_addr)));

        zeek_key->Assign(1, zeek::val_mgr->Port(key.port1));

        if ( IN6_IS_ADDR_V4MAPPED(&key.ip2) )
            zeek_key->Assign(2, zeek::make_intrusive<zeek::AddrVal>(*reinterpret_cast<const uint32_t*>(&key.ip2.s6_addr[12])));
        else
            zeek_key->Assign(2, zeek::make_intrusive<zeek::AddrVal>(reinterpret_cast<const uint32_t*>(&key.ip2.s6_addr)));

        zeek_key->Assign(3, zeek::val_mgr->Port(key.port2));
        zeek_key->Assign(4, zeek::val_mgr->Count(key.protocol));

        zeek_keys->Append(zeek_key);
    }

    return zeek_keys;
%}

# Adds the provided subnet to the source map. That means any addresses within that subnet
# as the source IP will get dropped.
function shunt_src_subnet%(xdp_prog: opaque of XDP::Program, net: subnet%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = shuntSubnet(get_src_ip_map(prog), net->AsSubNetVal());

    if ( err ) {
        zeek::reporter->Error(zeek::util::fmt("Failed to add to map: %s", (*err).c_str()));
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Stops shunting this source subnet
function unshunt_src_subnet%(xdp_prog: opaque of XDP::Program, net: subnet%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = unshuntSubnet(get_src_ip_map(prog), net->AsSubNetVal());

    if ( err ) {
        zeek::reporter->Error(zeek::util::fmt("Failed to remove from map: %s", (*err).c_str()));
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Adds the provided subnet to the destination map. That means any addresses within that subnet
# as the destination IP will get dropped.
function shunt_dest_subnet%(xdp_prog: opaque of XDP::Program, net: subnet%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = shuntSubnet(get_dest_ip_map(prog), net->AsSubNetVal());

    if ( err ) {
        zeek::reporter->Error(zeek::util::fmt("Failed to add to map: %s", (*err).c_str()));
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Stops shunting this source subnet
function unshunt_dest_subnet%(xdp_prog: opaque of XDP::Program, net: subnet%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = unshuntSubnet(get_dest_ip_map(prog), net->AsSubNetVal());

    if ( err ) {
        zeek::reporter->Error(zeek::util::fmt("Failed to remove from map: %s", (*err).c_str()));
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Shunts based on the 5-tuple, in both directions.
function shunt_conn_id%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : bool %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return zeek::val_mgr->Bool(false);

    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = update_map(get_canonical_id_map(prog), &*opt_tup, XDP_DROP);

    if ( err ) {
        zeek::reporter->Error(zeek::util::fmt("Failed to add to map: %s", (*err).c_str()));
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Stops shunting this conn_id
function unshunt_conn_id%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : bool %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return zeek::val_mgr->Bool(false);

    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = remove_from_map(get_canonical_id_map(prog), &*opt_tup);

    if ( err ) {
        zeek::reporter->Error(zeek::util::fmt("Failed to remove from map: %s", (*err).c_str()));
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# TODO: options
function end_shunt%(xdp_prog: opaque of XDP::Program%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    auto ifindex = if_nametoindex(ps->Path().c_str());
    if ( ifindex == 0 ) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    detach_and_destroy_filter(prog, ifindex);

    return zeek::val_mgr->Bool(true);
%}
