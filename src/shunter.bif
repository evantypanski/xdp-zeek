%%{
#include "zeek/iosource/Manager.h"
#include "zeek/iosource/PktSrc.h"

#include "bpf/UserXDP.h"
#include "bpf/filter_common.h"
#include "XDPProgram.h"

%%}
module XDP;

# TODO: options
function start_shunt%(%) : opaque of XDP::Program %{
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

		auto ifindex = if_nametoindex(ps->Path().c_str());
	  if (ifindex == 0) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    auto* skel = load_and_attach(ifindex);
    if (!skel) {
        // TODO: Make this error better since it can fail for 2 reasons
        zeek::reporter->Error("Failed to load BPF skeleton");
        return zeek::val_mgr->Bool(false);
    }

	  auto xdp_prog = zeek::make_intrusive<xdp::shunter::detail::XDPProgramVal>(skel);
    return xdp_prog;
%}

# Adds this 5-tuple to the BPF map
function drop%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : bool %{
    auto cid_r = cid->AsRecordVal();
    const zeek::IPAddr& orig_h = cid_r->GetFieldAs<zeek::AddrVal>(0);
    uint16_t orig_p = cid_r->GetFieldAs<zeek::PortVal>(1)->Port();
    const zeek::IPAddr& resp_h = cid_r->GetFieldAs<zeek::AddrVal>(2);
    uint16_t resp_p = cid_r->GetFieldAs<zeek::PortVal>(3)->Port();
    uint8_t proto = cid_r->GetFieldAs<zeek::CountVal>(4);

    // TODO: IPv6
    if ( orig_h.GetFamily() == IPv6 || resp_h.GetFamily() == IPv6 ) {
        zeek::reporter->Error("No IPV6 yet!!");
        return zeek::val_mgr->Bool(false);
    }

	  auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;

    const uint32_t* orig_bytes;
    int len = orig_h.GetBytes(&orig_bytes);
    if (len != 1) {
        zeek::reporter->Error("No support for IPs greater than 1 byte yet");
        return zeek::val_mgr->Bool(false);
    }
    const uint32_t* resp_bytes;
    len = resp_h.GetBytes(&resp_bytes);
    if (len != 1) {
        zeek::reporter->Error("No support for IPs greater than 1 byte yet");
        return zeek::val_mgr->Bool(false);
    }

    struct five_tuple tup = {
      .ip_orig = orig_bytes[0],
      .ip_resp = resp_bytes[0],
      .port_orig = orig_p,
      .port_resp = resp_p,
      .protocol = proto,
    };
    auto err = update_filter_map(prog, &tup, XDP_DROP);

    if (err) {
        zeek::reporter->Error("Failed to add to map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# TODO: options
function end_shunt%(xdp_prog: opaque of XDP::Program%) : bool %{
	  auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    // TODO: How could I get the ifindex without the if_nametoindex stuff?
		auto ifindex = if_nametoindex(ps->Path().c_str());
	  if (ifindex == 0) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    detach_and_destroy_filter(prog, ifindex);

    return zeek::val_mgr->Bool(true);
%}
