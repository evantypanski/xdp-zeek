##! BIFs for shunting with XDP. This is the main interface for XDP shunting.

%%{
#include "zeek/iosource/Manager.h"
#include "zeek/iosource/PktSrc.h"

#include "XDPProgram.h"
#include "bpf/UserXDP.h"
#include "bpf/filter_common.h"

struct in6_addr addrToIpVal(const zeek::IPAddr& addr) {
    const uint32_t* bytes;
    int len = addr.GetBytes(&bytes);
    struct in6_addr ip = {0};
    if ( len == 1 ) {
        ip.s6_addr[10] = 0xff;
        ip.s6_addr[11] = 0xff;
        memcpy(&ip.s6_addr[12], &bytes[0], sizeof(uint32_t));
    }
    else
        memcpy(&ip, bytes, sizeof(struct in6_addr));

    return ip;
}

std::optional<canonical_tuple> makeBPFMapTuple(zeek::RecordVal* cid_r) {
    const zeek::IPAddr& orig_h = cid_r->GetFieldAs<zeek::AddrVal>(0);
    uint16_t orig_p = cid_r->GetFieldAs<zeek::PortVal>(1)->Port();
    const zeek::IPAddr& resp_h = cid_r->GetFieldAs<zeek::AddrVal>(2);
    uint16_t resp_p = cid_r->GetFieldAs<zeek::PortVal>(3)->Port();
    uint8_t proto = cid_r->GetFieldAs<zeek::CountVal>(4);

    auto ip1 = addrToIpVal(orig_h);
    auto ip2 = addrToIpVal(resp_h);

    auto tup = canonical_tuple{
        .ip1 = ip1,
        .ip2 = ip2,
        .port1 = orig_p,
        .port2 = resp_p,
        .protocol = proto,
    };

    // We order first by ip, or if they're equal, by port.
    if ( compare_ips(&tup.ip1, &tup.ip2) > 0 || ((compare_ips(&tup.ip1, &tup.ip2) == 0) && tup.port1 > tup.port2) ) {
        // Flip them, they're out of order
        std::swap(tup.ip1, tup.ip2);
        std::swap(tup.port1, tup.port2);
    }

    return tup;
}

// Probably a better way to do this.
zeek::RecordValPtr makeEmptyShuntedStats() {
	  static auto shunt_stats_type = zeek::id::find_type<zeek::RecordType>("XDP::ShuntedStats");

    auto stats = zeek::make_intrusive<zeek::RecordVal>(shunt_stats_type);
		stats->Assign(0, zeek::val_mgr->Count(0));
		stats->Assign(1, zeek::val_mgr->Count(0));
		stats->Assign(2, zeek::val_mgr->Count(0));
		stats->Assign(3, zeek::val_mgr->Count(0));

		stats->Assign(5, zeek::val_mgr->Bool(false));

    return stats;
}

double mono_to_wall(uint64_t bpf_monotonic_ns) {
    // TODO: Should this use zeek's current_time? Probably! :)
    struct timespec real_now;
    clock_gettime(CLOCK_REALTIME, &real_now);
    uint64_t real_now_ns = (uint64_t)real_now.tv_sec * 1000000000 + real_now.tv_nsec;

    struct timespec mono_now;
    clock_gettime(CLOCK_MONOTONIC, &mono_now);
    uint64_t mono_now_ns = (uint64_t)mono_now.tv_sec * 1000000000 + mono_now.tv_nsec;

    uint64_t delta_ns = mono_now_ns - bpf_monotonic_ns;

    uint64_t packet_wall_time_ns = real_now_ns - delta_ns;

    // Convert to double-of-seconds
    return (double)packet_wall_time_ns / 1e9;
}

// The boolean decides which way ip1 was in the map
zeek::RecordValPtr makeShuntedStats(bool orig_is_ip1, const shunt_val* val) {
    static auto shunt_stats_type = zeek::id::find_type<zeek::RecordType>("XDP::ShuntedStats");
    auto stats = zeek::make_intrusive<zeek::RecordVal>(shunt_stats_type);

    if (orig_is_ip1) {
        stats->Assign(0, zeek::val_mgr->Count(val->packets_from_1));
        stats->Assign(1, zeek::val_mgr->Count(val->bytes_from_1));
        stats->Assign(2, zeek::val_mgr->Count(val->packets_from_2));
        stats->Assign(3, zeek::val_mgr->Count(val->bytes_from_2));
    } else {
        stats->Assign(0, zeek::val_mgr->Count(val->packets_from_2));
        stats->Assign(1, zeek::val_mgr->Count(val->bytes_from_2));
        stats->Assign(2, zeek::val_mgr->Count(val->packets_from_1));
        stats->Assign(3, zeek::val_mgr->Count(val->bytes_from_1));
    }

    if (val->timestamp != 0) {
        double packet_wall_time = mono_to_wall(val->timestamp);
        stats->Assign(4, zeek::make_intrusive<zeek::TimeVal>(packet_wall_time));
    }

    stats->Assign(5, zeek::val_mgr->Bool(true));

    return stats;
}

bool origIsIp1(zeek::RecordVal* cid_r) {
    const zeek::IPAddr& orig_h = cid_r->GetFieldAs<zeek::AddrVal>(0);
    const zeek::IPAddr& resp_h = cid_r->GetFieldAs<zeek::AddrVal>(2);

    auto ip1 = addrToIpVal(orig_h);
    auto ip2 = addrToIpVal(resp_h);

    // TODO: Check if this is accurate, might be flipped
    return compare_ips(&ip1, &ip2) < 0;
}

%%}

module XDP;

## Begins shunting with XDP by loading the XDP program and necessary BPF maps.
##
## Returns: An opaque value representing the now-attached BPF program
##
## .. zeek:see:: end_shunt
function start_shunt%(options: XDP::ShuntOptions%) : opaque of XDP::Program %{
    auto options_val = IntrusivePtr<RecordVal>{NewRef{}, options->AsRecordVal()};
    auto opts = xdp_options{
        .mode = static_cast<xdp_attach_mode>(options_val->GetFieldAs<zeek::EnumVal>("attach_mode")),
    };
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        // TODO: This is returning false, but should probably be another expected type
        return zeek::val_mgr->Bool(false);
    }

    auto ifindex = if_nametoindex(ps->Path().c_str());
    if ( ifindex == 0 ) {
        zeek::reporter->Error("Invalid device");
        return zeek::val_mgr->Bool(false);
    }

    struct filter* skel = nullptr;
    auto err = load_and_attach(ifindex, opts, &skel);
    if ( err ) {
        zeek::reporter->Error("Failed to load BPF skeleton: %s", (*err).c_str());
        return zeek::val_mgr->Bool(false);
    }

    auto xdp_prog = zeek::make_intrusive<xdp::shunter::detail::XDPProgramVal>(skel);
    return xdp_prog;
%}

## Retrieves the current values in the canonical ID map.
##
## Returns: A table of the "canonical" connection IDs getting shunted
function get_canonical_id_map%(xdp_prog: opaque of XDP::Program%) : shunt_table %{
    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
	static auto shunt_table = zeek::id::find_type<zeek::TableType>("XDP::shunt_table");
    auto zeek_table = zeek::make_intrusive<zeek::TableVal>(shunt_table);

    if ( ! zeek_prog ) {
        zeek::reporter->Error(zeek_prog.error().c_str());
        return zeek_table;
    }

    auto prog = (*zeek_prog)->prog;

    auto shunt_map = get_map<canonical_tuple>(get_canonical_id_map(prog));
    for ( const auto&[key, val] : shunt_map ) {
        auto zeek_key = zeek::make_intrusive<zeek::RecordVal>(zeek::id::conn_id);
        if ( IN6_IS_ADDR_V4MAPPED(&key.ip1) )
            zeek_key->Assign(0, zeek::make_intrusive<zeek::AddrVal>(
                                    *reinterpret_cast<const uint32_t*>(&key.ip1.s6_addr[12])));
        else
            zeek_key->Assign(0,
                             zeek::make_intrusive<zeek::AddrVal>(reinterpret_cast<const uint32_t*>(&key.ip1.s6_addr)));

        zeek_key->Assign(1, zeek::val_mgr->Port(key.port1));

        if ( IN6_IS_ADDR_V4MAPPED(&key.ip2) )
            zeek_key->Assign(2, zeek::make_intrusive<zeek::AddrVal>(
                                    *reinterpret_cast<const uint32_t*>(&key.ip2.s6_addr[12])));
        else
            zeek_key->Assign(2,
                             zeek::make_intrusive<zeek::AddrVal>(reinterpret_cast<const uint32_t*>(&key.ip2.s6_addr)));

        zeek_key->Assign(3, zeek::val_mgr->Port(key.port2));
        zeek_key->Assign(4, zeek::val_mgr->Count(key.protocol));

        zeek_table->Assign(zeek_key, makeShuntedStats(true, &val));
    }

    return zeek_table;
%}

## Retrieves the current values in the canonical ID map.
##
## Returns: A table of the IP pairs getting shunted
function get_ip_pair_map%(xdp_prog: opaque of XDP::Program%) : ip_pair_shunt_table %{
    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
	static auto ip_shunt_table = zeek::id::find_type<zeek::TableType>("XDP::ip_pair_shunt_table");
	static auto ip_pair = zeek::id::find_type<zeek::RecordType>("XDP::ip_pair");
    auto zeek_table = zeek::make_intrusive<zeek::TableVal>(ip_shunt_table);

    if ( ! zeek_prog ) {
        zeek::reporter->Error(zeek_prog.error().c_str());
        return zeek_table;
    }

    auto prog = (*zeek_prog)->prog;

    auto shunt_map = get_map<ip_pair_key>(get_ip_pair_map(prog));
    for ( const auto&[key, val] : shunt_map ) {
        auto zeek_key = zeek::make_intrusive<zeek::RecordVal>(ip_pair);
        if ( IN6_IS_ADDR_V4MAPPED(&key.ip1) )
            zeek_key->Assign(0, zeek::make_intrusive<zeek::AddrVal>(
                                    *reinterpret_cast<const uint32_t*>(&key.ip1.s6_addr[12])));
        else
            zeek_key->Assign(0,
                             zeek::make_intrusive<zeek::AddrVal>(reinterpret_cast<const uint32_t*>(&key.ip1.s6_addr)));

        if ( IN6_IS_ADDR_V4MAPPED(&key.ip2) )
            zeek_key->Assign(1, zeek::make_intrusive<zeek::AddrVal>(
                                    *reinterpret_cast<const uint32_t*>(&key.ip2.s6_addr[12])));
        else
            zeek_key->Assign(1,
                             zeek::make_intrusive<zeek::AddrVal>(reinterpret_cast<const uint32_t*>(&key.ip2.s6_addr)));

        zeek_table->Assign(zeek_key, makeShuntedStats(true, &val));
    }

    return zeek_table;
%}

## Starts shunting anything between two IPs.
##
## Returns: Whether the operation succeeded
##
## .. zeek:see:: unshunt_ip_pair ip_pair_shunt_stats
function shunt_ip_pair%(xdp_prog: opaque of XDP::Program, ip1_val: addr, ip2_val: addr%) : bool %{
    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    if ( ! zeek_prog ) {
        zeek::reporter->Error(zeek_prog.error().c_str());
        return zeek::val_mgr->Bool(false);
    }

    auto prog = (*zeek_prog)->prog;
    auto ip1 = addrToIpVal(ip1_val->AsAddrVal()->Get());
    auto ip2 = addrToIpVal(ip2_val->AsAddrVal()->Get());

    auto ip2_higher = compare_ips(&ip1, &ip2) < 0;

    auto key = ip_pair_key{
        .ip1 = ip2_higher ? ip1 : ip2,
        .ip2 = ip2_higher ? ip2 : ip1,
    };

    auto err = update_map(get_ip_pair_map(prog), &key);

    if ( err ) {
        zeek::reporter->Error(zeek::util::fmt("Failed to add to map: %s", (*err).c_str()));
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

## Provides the shunting statistics for this IP pair.
##
## Returns: The shunting statistics
##
## .. zeek:see:: shunt_ip_pair unshunt_ip_pair
function ip_pair_shunt_stats%(xdp_prog: opaque of XDP::Program, orig_h: addr, resp_h: addr%) : XDP::ShuntedStats %{
    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    if ( ! zeek_prog ) {
        zeek::reporter->Error(zeek_prog.error().c_str());
        return makeEmptyShuntedStats();
    }

    auto prog = (*zeek_prog)->prog;
    auto ip1 = addrToIpVal(orig_h->AsAddrVal()->Get());
    auto ip2 = addrToIpVal(resp_h->AsAddrVal()->Get());

    auto ip2_higher = compare_ips(&ip1, &ip2) < 0;

    auto key = ip_pair_key{
        .ip1 = ip2_higher ? ip1 : ip2,
        .ip2 = ip2_higher ? ip2 : ip1,
    };
    auto opt_val = get_val(get_ip_pair_map(prog), &key);
    if ( ! opt_val )
        return makeEmptyShuntedStats();

    return makeShuntedStats(ip2_higher, &*opt_val);
%}

## Stops shunting anything between two IPs.
##
## TODO: Make this return the value?
##
## Returns: Whether the operation succeeded
##
## .. zeek:see:: shunt_ip_pair ip_pair_shunt_stats
function unshunt_ip_pair%(xdp_prog: opaque of XDP::Program, ip1_val: addr, ip2_val: addr%) : XDP::ShuntedStats %{
    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    if ( ! zeek_prog ) {
        zeek::reporter->Error(zeek_prog.error().c_str());
        return makeEmptyShuntedStats();
    }

    auto prog = (*zeek_prog)->prog;
    auto ip1 = addrToIpVal(ip1_val->AsAddrVal()->Get());
    auto ip2 = addrToIpVal(ip2_val->AsAddrVal()->Get());

    auto ip2_higher = compare_ips(&ip1, &ip2) < 0;

    auto key = ip_pair_key{
        .ip1 = ip2_higher ? ip1 : ip2,
        .ip2 = ip2_higher ? ip2 : ip1,
    };

    auto opt_val = get_val(get_ip_pair_map(prog), &key);
    if ( ! opt_val )
        return makeEmptyShuntedStats();

    auto err = remove_from_map(get_ip_pair_map(prog), &key);

    if ( err ) {
        zeek::reporter->Error(zeek::util::fmt("Failed to add to map: %s", (*err).c_str()));
        return makeEmptyShuntedStats();
    }

    return makeShuntedStats(ip2_higher, &*opt_val);
%}

## Starts shunting anything with the conn_id. This is bidirectional.
##
## Returns: Whether the operation succeeded
##
## .. zeek:see:: unshunt_conn_id conn_id_shunt_stats
function shunt_conn_id%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : bool %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return zeek::val_mgr->Bool(false);

    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    if ( ! zeek_prog ) {
        zeek::reporter->Error(zeek_prog.error().c_str());
        return zeek::val_mgr->Bool(false);
    }

    auto prog = (*zeek_prog)->prog;
    auto err = update_map(get_canonical_id_map(prog), &*opt_tup);

    if ( err ) {
        zeek::reporter->Error(zeek::util::fmt("Failed to add to map: %s", (*err).c_str()));
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

## Provides the shunting statistics for this connection ID.
##
## Returns: The shunting statistics
##
## .. zeek:see:: shunt_conn_id unshunt_conn_id
function conn_id_shunt_stats%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : XDP::ShuntedStats %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return makeEmptyShuntedStats();

    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    if ( ! zeek_prog ) {
        zeek::reporter->Error(zeek_prog.error().c_str());
        return makeEmptyShuntedStats();
    }

    auto prog = (*zeek_prog)->prog;
    auto opt_val = get_val(get_canonical_id_map(prog), &*opt_tup);
    if ( ! opt_val )
        return makeEmptyShuntedStats();

    return makeShuntedStats(origIsIp1(cid->AsRecordVal()), &*opt_val);
%}

## Stops shunting anything with the conn_id.
##
## TODO: Make this return the value?
##
## Returns: Whether the operation succeeded
##
## .. zeek:see:: shunt_conn_id conn_id_shunt_stats
function unshunt_conn_id%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : XDP::ShuntedStats %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return makeEmptyShuntedStats();

    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    if ( ! zeek_prog ) {
        zeek::reporter->Error(zeek_prog.error().c_str());
        return makeEmptyShuntedStats();
    }

    auto prog = (*zeek_prog)->prog;

    auto opt_val = get_val(get_canonical_id_map(prog), &*opt_tup);
    if ( ! opt_val )
        return makeEmptyShuntedStats();

    auto err = remove_from_map(get_canonical_id_map(prog), &*opt_tup);

    if ( err ) {
        zeek::reporter->Error(zeek::util::fmt("Failed to remove from map: %s", (*err).c_str()));
        return makeEmptyShuntedStats();
    }

    return makeShuntedStats(origIsIp1(cid->AsRecordVal()), &*opt_val);
%}

## Stops the XDP shunting program.
##
## Returns: Whether the operation succeeded
##
## .. zeek:see:: start_shunt
function end_shunt%(xdp_prog: opaque of XDP::Program%) : bool %{
    auto zeek_prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog);
    if ( ! zeek_prog ) {
        zeek::reporter->Error(zeek_prog.error().c_str());
        return zeek::val_mgr->Bool(false);
    }

    auto prog = (*zeek_prog)->prog;
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    auto ifindex = if_nametoindex(ps->Path().c_str());
    if ( ifindex == 0 ) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    detach_and_destroy_filter(prog, ifindex);

    return zeek::val_mgr->Bool(true);
%}
