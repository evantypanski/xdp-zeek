%%{
#include "zeek/iosource/Manager.h"
#include "zeek/iosource/PktSrc.h"

#include "bpf/UserXDP.h"
#include "bpf/filter_common.h"
#include "XDPProgram.h"

%%}
module XDP;

# TODO: options
function start_shunt%(%) : opaque of XDP::Program %{
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

		auto ifindex = if_nametoindex(ps->Path().c_str());
	  if (ifindex == 0) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    auto* skel = load_and_attach(ifindex);
    if (!skel) {
        // TODO: Make this error better since it can fail for 2 reasons
        zeek::reporter->Error("Failed to load BPF skeleton");
        return zeek::val_mgr->Bool(false);
    }

	  auto xdp_prog = zeek::make_intrusive<xdp::shunter::detail::XDPProgramVal>(skel);
    return xdp_prog;
%}

# Adds this 5-tuple to the BPF map
function drop%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : bool %{
    auto cid_r = cid->AsRecordVal();
    const zeek::IPAddr& orig_h = cid_r->GetFieldAs<zeek::AddrVal>(0);
    uint16_t orig_p = cid_r->GetFieldAs<zeek::PortVal>(1)->Port();
    const zeek::IPAddr& resp_h = cid_r->GetFieldAs<zeek::AddrVal>(2);
    uint16_t resp_p = cid_r->GetFieldAs<zeek::PortVal>(3)->Port();
    uint8_t proto = cid_r->GetFieldAs<zeek::CountVal>(4);

    // TODO: IPv6
    if ( orig_h.GetFamily() == IPv6 || resp_h.GetFamily() == IPv6 ) {
        zeek::reporter->Error("No IPV6 yet!!");
        return zeek::val_mgr->Bool(false);
    }

	  auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;

    struct five_tuple tup = {0};
    const uint32_t* bytes;
    // TODO: Check len and stuff.
    int len = orig_h.GetBytes(&bytes);
    tup.ip_source = bytes[0];
    tup.port_source = orig_p;
    len = resp_h.GetBytes(&bytes);
    tup.ip_destination = bytes[0];
    tup.port_destination = resp_p;
    tup.protocol = proto;
    enum xdp_action action = XDP_DROP;
    auto err = update_filter_map(prog, &tup, action);

    if (err) {
        zeek::reporter->Error("Failed to add to map");
        return zeek::val_mgr->Bool(false);
    }

    // Workaround: Now shunt the other direction :) just for demonstration
    // This may get encoded in the update filter map, or not. idk.
    auto tmp = tup.ip_destination;
    tup.ip_destination = tup.ip_source;
    tup.ip_source = tmp;
    auto port_tmp = tup.port_destination;
    tup.port_destination = tup.port_source;
    tup.port_source = port_tmp;
    err = update_filter_map(prog, &tup, action);

    if (err) {
        zeek::reporter->Error("Failed to add to map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# TODO: options
function end_shunt%(xdp_prog: opaque of XDP::Program%) : bool %{
	  auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    // TODO: How could I get the ifindex without the if_nametoindex stuff?
		auto ifindex = if_nametoindex(ps->Path().c_str());
	  if (ifindex == 0) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    detach_and_destroy_filter(prog, ifindex);

    return zeek::val_mgr->Bool(true);
%}
