%%{
#include "zeek/iosource/Manager.h"
#include "zeek/iosource/PktSrc.h"

#include "XDPProgram.h"
#include "bpf/UserXDP.h"
#include "bpf/filter_common.h"

std::optional<canonical_tuple> makeBPFMapTuple(zeek::RecordVal* cid_r) {
    const zeek::IPAddr& orig_h = cid_r->GetFieldAs<zeek::AddrVal>(0);
    uint16_t orig_p = cid_r->GetFieldAs<zeek::PortVal>(1)->Port();
    const zeek::IPAddr& resp_h = cid_r->GetFieldAs<zeek::AddrVal>(2);
    uint16_t resp_p = cid_r->GetFieldAs<zeek::PortVal>(3)->Port();
    uint8_t proto = cid_r->GetFieldAs<zeek::CountVal>(4);

    // TODO: IPv6
    if ( orig_h.GetFamily() == IPv6 || resp_h.GetFamily() == IPv6 ) {
        zeek::reporter->Error("No IPV6 yet!!");
        // TODO: Make a result type for these errors
        return {};
    }

    const uint32_t* orig_bytes;
    int len = orig_h.GetBytes(&orig_bytes);
    if ( len != 1 ) {
        zeek::reporter->Error("No support for IPs greater than 1 byte yet");
        return {};
    }
    const uint32_t* resp_bytes;
    len = resp_h.GetBytes(&resp_bytes);
    if ( len != 1 ) {
        zeek::reporter->Error("No support for IPs greater than 1 byte yet");
        return {};
    }

    auto tup = canonical_tuple{
        .ip1 = orig_bytes[0],
        .ip2 = resp_bytes[0],
        .port1 = orig_p,
        .port2 = resp_p,
        .protocol = proto,
    };

    // We order first by ip, or if they're equal, by port.
    if ( tup.ip2 < tup.ip1 || (tup.ip1 == tup.ip2 && tup.port2 < tup.port1) ) {
        // Flip them, they're out of order
        std::swap(tup.ip1, tup.ip2);
        std::swap(tup.port1, tup.port2);
    }

    return tup;
}

%%}
module XDP;

function start_shunt%(options: XDP::ShuntOptions%) : opaque of XDP::Program %{
    auto options_val = IntrusivePtr<RecordVal>{NewRef{}, options->AsRecordVal()};
    auto opts = xdp_options {
        .mode = static_cast<xdp_attach_mode>(options_val->GetFieldAs<zeek::EnumVal>("attach_mode")),
    };
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    auto ifindex = if_nametoindex(ps->Path().c_str());
    if ( ifindex == 0 ) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    auto* skel = load_and_attach(ifindex, opts);
    if ( ! skel ) {
        // TODO: Make this error better since it can fail for 2 reasons
        zeek::reporter->Error("Failed to load BPF skeleton");
        return zeek::val_mgr->Bool(false);
    }

    auto xdp_prog = zeek::make_intrusive<xdp::shunter::detail::XDPProgramVal>(skel);
    return xdp_prog;
%}

# Adds the provided subnet to the source map. That means any addresses within that subnet
# as the source IP will get dropped.
function shunt_src_subnet%(xdp_prog: opaque of XDP::Program, net: subnet%) : bool %{
    auto net_val = net->AsSubNetVal();
    auto ip = net_val->Prefix();
    const uint32_t* bytes;
    int len = ip.GetBytes(&bytes);
    if ( len != 1 ) {
        zeek::reporter->Error("No support for IPs greater than 1 byte yet");
        return {};
    }
    auto key = ip_lpm_key {
        .prefixlen = static_cast<__u32>(net_val->Width()),
        .ip = bytes[0],
    };

    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = update_map(get_src_ip_map(prog), &key, XDP_DROP);

    if ( err ) {
        zeek::reporter->Error("Failed to add to map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Stops shunting this source subnet
function unshunt_src_subnet%(xdp_prog: opaque of XDP::Program, net: subnet%) : bool %{
    auto net_val = net->AsSubNetVal();
    auto ip = net_val->Prefix();
    const uint32_t* bytes;
    int len = ip.GetBytes(&bytes);
    if ( len != 1 ) {
        zeek::reporter->Error("No support for IPs greater than 1 byte yet");
        return {};
    }
    auto key = ip_lpm_key {
        .prefixlen = static_cast<__u32>(net_val->Width()),
        .ip = bytes[0],
    };

    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = update_map(get_src_ip_map(prog), &key, XDP_DROP);

    if ( err ) {
        zeek::reporter->Error("Failed to remove from map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}


# Shunts based on the 5-tuple, in both directions.
function shunt_conn_id%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : bool %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return zeek::val_mgr->Bool(false);

    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = update_map(get_canonical_id_map(prog), &*opt_tup, XDP_DROP);

    if ( err ) {
        zeek::reporter->Error("Failed to add to map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Stops shunting this conn_id
function unshunt_conn_id%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : bool %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return zeek::val_mgr->Bool(false);

    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = remove_from_map(get_canonical_id_map(prog), &*opt_tup);

    if ( err ) {
        zeek::reporter->Error("Failed to remove from map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# TODO: options
function end_shunt%(xdp_prog: opaque of XDP::Program%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    // TODO: How could I get the ifindex without the if_nametoindex stuff?
    auto ifindex = if_nametoindex(ps->Path().c_str());
    if ( ifindex == 0 ) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    detach_and_destroy_filter(prog, ifindex);

    return zeek::val_mgr->Bool(true);
%}
