%%{
#include "zeek/iosource/Manager.h"
#include "zeek/iosource/PktSrc.h"

#include "bpf/common_defines.h"
#include "bpf/common_user_bpf_xdp.h"
#include "bpf/filter_common.h"
#include "XDPProgram.h"

%%}
module XDP;

# TODO: options
function start_shunt%(%) : opaque of XDP::Program %{
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    auto* skel = open_and_load_bpf();
    if (!skel) {
        zeek::reporter->Error("Failed to load BPF skeleton");
        return zeek::val_mgr->Bool(false);
    }

    // TODO: Don't hardcode the mode
    // TODO: How could I get the ifindex without the if_nametoindex stuff?
		auto ifindex = if_nametoindex(ps->Path().c_str());
	  if (ifindex == 0) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    auto prog_fd = get_bpf_program_fd(skel);
    if (prog_fd == 0) {
        zeek::reporter->Error("Failed to get FD");
        return zeek::val_mgr->Bool(false);
    }

    int err = bpf_xdp_attach(ifindex, prog_fd, XDP_MODE_SKB, 0);
    if (err) {
        zeek::reporter->Error("Failed to attach");
        return zeek::val_mgr->Bool(false);
    }

	  auto xdp_prog = zeek::make_intrusive<xdp::shunter::detail::XDPProgramVal>(skel);
    return xdp_prog;
%}

# Adds this 5-tuple to the BPF map
function drop%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : bool %{
    auto cid_r = cid->AsRecordVal();
    const zeek::IPAddr& orig_h = cid_r->GetFieldAs<zeek::AddrVal>(0);
    uint32_t orig_p = cid_r->GetFieldAs<zeek::PortVal>(1)->Port();
    const zeek::IPAddr& resp_h = cid_r->GetFieldAs<zeek::AddrVal>(2);
    uint32_t resp_p = cid_r->GetFieldAs<zeek::PortVal>(3)->Port();

    // TODO: IPv6
    if ( orig_h.GetFamily() == IPv6 || resp_h.GetFamily() == IPv6 ) {
        zeek::reporter->Error("No IPV6 yet!!");
        return zeek::val_mgr->Bool(false);
    }

	  auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto* map = get_bpf_filter_map(prog);
    if (!map) {
        zeek::reporter->Error("Failed to find 'filter_map' in BPF object");
        return zeek::val_mgr->Bool(false);
    }
    struct five_tuple tup = {0};
    const uint32_t* bytes;
    // TODO: Check len and stuff.
    int len = orig_h.GetBytes(&bytes);
    tup.ip_source = bytes[0];
    len = resp_h.GetBytes(&bytes);
    tup.ip_destination = bytes[0];
    enum xdp_action action = XDP_DROP;
    auto err = bpf_map__update_elem(map, &tup, sizeof(tup), &action, sizeof(action), 0);
    if (err) {
        zeek::reporter->Error("Failed to add to map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# TODO: options
function end_shunt%(xdp_prog: opaque of XDP::Program%) : bool %{
	  auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    // TODO: How could I get the ifindex without the if_nametoindex stuff?
		auto ifindex = if_nametoindex(ps->Path().c_str());
	  if (ifindex == 0) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    detach_and_destroy_filter(prog, ifindex);

    return zeek::val_mgr->Bool(true);
%}
