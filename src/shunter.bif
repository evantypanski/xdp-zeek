%%{
#include "zeek/iosource/Manager.h"
#include "zeek/iosource/PktSrc.h"

#include "XDPProgram.h"
#include "bpf/UserXDP.h"
#include "bpf/filter_common.h"

std::optional<canonical_tuple> makeBPFMapTuple(zeek::RecordVal* cid_r) {
    const zeek::IPAddr& orig_h = cid_r->GetFieldAs<zeek::AddrVal>(0);
    uint16_t orig_p = cid_r->GetFieldAs<zeek::PortVal>(1)->Port();
    const zeek::IPAddr& resp_h = cid_r->GetFieldAs<zeek::AddrVal>(2);
    uint16_t resp_p = cid_r->GetFieldAs<zeek::PortVal>(3)->Port();
    uint8_t proto = cid_r->GetFieldAs<zeek::CountVal>(4);

    // TODO: IPv6
    if ( orig_h.GetFamily() == IPv6 || resp_h.GetFamily() == IPv6 ) {
        zeek::reporter->Error("No IPV6 yet!!");
        // TODO: Make a result type for these errors
        return {};
    }

    const uint32_t* orig_bytes;
    int len = orig_h.GetBytes(&orig_bytes);
    if ( len != 1 ) {
        zeek::reporter->Error("No support for IPs greater than 1 byte yet");
        return {};
    }
    const uint32_t* resp_bytes;
    len = resp_h.GetBytes(&resp_bytes);
    if ( len != 1 ) {
        zeek::reporter->Error("No support for IPs greater than 1 byte yet");
        return {};
    }

    auto tup = canonical_tuple{
        .ip1 = orig_bytes[0],
        .ip2 = resp_bytes[0],
        .port1 = orig_p,
        .port2 = resp_p,
        .protocol = proto,
    };

    // We order first by ip, or if they're equal, by port.
    if ( tup.ip2 < tup.ip1 || (tup.ip1 == tup.ip2 && tup.port2 < tup.port1) ) {
        // Flip them, they're out of order
        std::swap(tup.ip1, tup.ip2);
        std::swap(tup.port1, tup.port2);
    }

    return tup;
}

int shuntSubnet(struct bpf_map* map, zeek::SubNetVal* subnet) {
    auto ip = subnet->Prefix();
    const uint32_t* bytes;
    int len = ip.GetBytes(&bytes);
    if ( len != 1 ) {
        zeek::reporter->Error("No support for IPs greater than 1 byte yet");
        return -1;
    }
    auto key = ip_lpm_key {
        .prefixlen = static_cast<__u32>(subnet->Width()),
        .ip = bytes[0],
    };

    return update_map(map, &key, XDP_DROP);
}

int unshuntSubnet(struct bpf_map* map, zeek::SubNetVal* subnet) {
    auto ip = subnet->Prefix();
    const uint32_t* bytes;
    int len = ip.GetBytes(&bytes);
    if ( len != 1 ) {
        zeek::reporter->Error("No support for IPs greater than 1 byte yet");
        return {};
    }
    auto key = ip_lpm_key {
        .prefixlen = static_cast<__u32>(subnet->Width()),
        .ip = bytes[0],
    };

    return remove_from_map(map, &key);
}

%%}
module XDP;

function start_shunt%(options: XDP::ShuntOptions%) : opaque of XDP::Program %{
    auto options_val = IntrusivePtr<RecordVal>{NewRef{}, options->AsRecordVal()};
    auto opts = xdp_options {
        .mode = static_cast<xdp_attach_mode>(options_val->GetFieldAs<zeek::EnumVal>("attach_mode")),
    };
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    auto ifindex = if_nametoindex(ps->Path().c_str());
    if ( ifindex == 0 ) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    auto* skel = load_and_attach(ifindex, opts);
    if ( ! skel ) {
        // TODO: Make this error better since it can fail for 2 reasons
        zeek::reporter->Error("Failed to load BPF skeleton");
        return zeek::val_mgr->Bool(false);
    }

    auto xdp_prog = zeek::make_intrusive<xdp::shunter::detail::XDPProgramVal>(skel);
    return xdp_prog;
%}

function get_canonical_id_map_keys%(xdp_prog: opaque of XDP::Program%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto keys = get_map<canonical_tuple>(get_canonical_id_map(prog));
    auto zeek_keys = zeek::make_intrusive<zeek::VectorVal>(zeek::make_intrusive<zeek::VectorType>(zeek::id::conn_id));
    for (auto key : keys) {
	      auto zeek_key = zeek::make_intrusive<zeek::RecordVal>(zeek::id::conn_id);
        zeek_key->Assign(0, zeek::make_intrusive<zeek::AddrVal>(key.ip1));
        zeek_key->Assign(1, zeek::val_mgr->Port(key.port1));
        zeek_key->Assign(2, zeek::make_intrusive<zeek::AddrVal>(key.ip2));
        zeek_key->Assign(3, zeek::val_mgr->Port(key.port2));
        zeek_key->Assign(4, zeek::val_mgr->Count(key.protocol));
        zeek_keys->Append(zeek_key);
    }

    return zeek_keys;
%}

# Adds the provided subnet to the source map. That means any addresses within that subnet
# as the source IP will get dropped.
function shunt_src_subnet%(xdp_prog: opaque of XDP::Program, net: subnet%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = shuntSubnet(get_src_ip_map(prog), net->AsSubNetVal());

    if ( err ) {
        zeek::reporter->Error("Failed to add to map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Stops shunting this source subnet
function unshunt_src_subnet%(xdp_prog: opaque of XDP::Program, net: subnet%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = unshuntSubnet(get_src_ip_map(prog), net->AsSubNetVal());

    if ( err ) {
        zeek::reporter->Error("Failed to remove from map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Adds the provided subnet to the destination map. That means any addresses within that subnet
# as the destination IP will get dropped.
function shunt_dest_subnet%(xdp_prog: opaque of XDP::Program, net: subnet%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = shuntSubnet(get_dest_ip_map(prog), net->AsSubNetVal());

    if ( err ) {
        zeek::reporter->Error("Failed to add to map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Stops shunting this source subnet
function unshunt_dest_subnet%(xdp_prog: opaque of XDP::Program, net: subnet%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = unshuntSubnet(get_dest_ip_map(prog), net->AsSubNetVal());

    if ( err ) {
        zeek::reporter->Error("Failed to remove from map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Shunts based on the 5-tuple, in both directions.
function shunt_conn_id%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : bool %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return zeek::val_mgr->Bool(false);

    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = update_map(get_canonical_id_map(prog), &*opt_tup, XDP_DROP);

    if ( err ) {
        zeek::reporter->Error("Failed to add to map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# Stops shunting this conn_id
function unshunt_conn_id%(xdp_prog: opaque of XDP::Program, cid: conn_id%) : bool %{
    auto opt_tup = makeBPFMapTuple(cid->AsRecordVal());
    if ( ! opt_tup )
        return zeek::val_mgr->Bool(false);

    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto err = remove_from_map(get_canonical_id_map(prog), &*opt_tup);

    if ( err ) {
        zeek::reporter->Error("Failed to remove from map");
        return zeek::val_mgr->Bool(false);
    }

    return zeek::val_mgr->Bool(true);
%}

# TODO: options
function end_shunt%(xdp_prog: opaque of XDP::Program%) : bool %{
    auto prog = xdp::shunter::detail::XDPProgramVal::CastFromAny(xdp_prog)->prog;
    auto ps = zeek::iosource_mgr->GetPktSrc();
    if ( ! ps ) {
        zeek::reporter->Error("Packet source invalid!");
        return zeek::val_mgr->Bool(false);
    }

    // TODO: How could I get the ifindex without the if_nametoindex stuff?
    auto ifindex = if_nametoindex(ps->Path().c_str());
    if ( ifindex == 0 ) {
        zeek::reporter->Error("Invalid device?");
        return zeek::val_mgr->Bool(false);
    }

    detach_and_destroy_filter(prog, ifindex);

    return zeek::val_mgr->Bool(true);
%}
